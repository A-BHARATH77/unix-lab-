ls command 
#include <stdio.h>
#include <stdlib.h>
#include <dirent.h>  // For opendir(), readdir(), closedir()
#include <errno.h>   // For errno, perror()

int main(int argc, char *argv[]) {
    DIR *dir;                     // Pointer to the directory
    struct dirent *entry;          // Struct to hold directory entry
    char *directory;

    // If no directory is provided, use the current directory
    if (argc == 1) {
        directory = ".";
    } else if (argc == 2) {
        directory = argv[1];       // Use the directory provided as an argument
    } else {
        fprintf(stderr, "Usage: %s [directory]\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    // Open the directory
    dir = opendir(directory);
    if (dir == NULL) {
        perror("Error opening directory");
        exit(EXIT_FAILURE);
    }

    // Read and print entries from the directory
    while ((entry = readdir(dir)) != NULL) {
        printf("%s\n", entry->d_name);  // Print the name of the entry
    }

    // Close the directory
    closedir(dir);

    return 0;
}

//gcc -o my_ls my_ls.c - compile
//./my_ls -run


cat command 
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>    // For open()
#include <unistd.h>   // For read(), write(), close()

#define BUFFER_SIZE 1024

void display_file_content(const char *filename) {
    int fd;                     // File descriptor
    char buffer[BUFFER_SIZE];    // Buffer to hold file content
    ssize_t bytes_read;          // Number of bytes read

    // 1. Open the file for reading (O_RDONLY)
    fd = open(filename, O_RDONLY);
    if (fd < 0) {
        perror("Error opening file");
        exit(EXIT_FAILURE);
    }

    // 2. Read from the file and write to standard output (STDOUT_FILENO)
    while ((bytes_read = read(fd, buffer, BUFFER_SIZE)) > 0) {
        // Write the content to standard output
        if (write(STDOUT_FILENO, buffer, bytes_read) != bytes_read) {
            perror("Error writing to stdout");
            close(fd);
            exit(EXIT_FAILURE);
        }
    }

    // If read returns -1, there was an error
    if (bytes_read < 0) {
        perror("Error reading file");
        close(fd);
        exit(EXIT_FAILURE);
    }

    // 3. Close the file descriptor
    close(fd);
}

int main(int argc, char *argv[]) {
    // Check if the correct number of arguments is provided
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <filename>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    // Call the function to display the file's content
    display_file_content(argv[1]);

    return 0;
}


cp command 
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[]) {
    // Ensure two arguments are provided: source file and destination file
    if (argc != 3) {
        fprintf(stderr, "Usage: %s <sourcefile> <destinationfile>\n", argv[0]);
        exit(1);
    }

    // Open the source file for reading
    FILE *source_file = fopen(argv[1], "r");
    if (source_file == NULL) {
        perror("Error opening source file");
        exit(1);
    }

    // Open the destination file for writing (create it if it doesn't exist)
    FILE *destination_file = fopen(argv[2], "w");
    if (destination_file == NULL) {
        perror("Error opening destination file");
        fclose(source_file);  // Close the source file before exiting
        exit(1);
    }

    // Copy the contents from source file to destination file
    char ch;
    while ((ch = fgetc(source_file)) != EOF) {
        fputc(ch, destination_file);  // Write each character to the destination file
    }

    // Close both files
    fclose(source_file);
    fclose(destination_file);

Case 1: Two Pipes with Three Processes
Example Code
c
Copy code
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main() {
    int pipe1[2], pipe2[2];
    pid_t p1, p2, p3;

    // Create the first pipe
    if (pipe(pipe1) == -1) {
        perror("pipe1");
        exit(EXIT_FAILURE);
    }

    // Create the second pipe
    if (pipe(pipe2) == -1) {
        perror("pipe2");
        exit(EXIT_FAILURE);
    }

    // First process (p1)
    p1 = fork();
    if (p1 < 0) {
        perror("fork p1");
        exit(EXIT_FAILURE);
    }

    if (p1 == 0) {
        // Child process p1
        close(pipe1[0]); // Close read end of pipe1
        for (int i = 1; i <= 5; i++) {
            write(pipe1[1], &i, sizeof(i)); // Write integers 1 to 5
        }
        close(pipe1[1]); // Close write end
        exit(EXIT_SUCCESS);
    }

    // Second process (p2)
    p2 = fork();
    if (p2 < 0) {
        perror("fork p2");
        exit(EXIT_FAILURE);
    }

    if (p2 == 0) {
        // Child process p2
        close(pipe1[1]); // Close write end of pipe1
        close(pipe2[0]); // Close read end of pipe2

        int num;
        while (read(pipe1[0], &num, sizeof(num)) > 0) {
            num *= 2; // Process the number (double it)
            write(pipe2[1], &num, sizeof(num)); // Send to process p3
        }
        close(pipe1[0]); // Close read end of pipe1
        close(pipe2[1]); // Close write end
        exit(EXIT_SUCCESS);
    }

    // Third process (p3)
    p3 = fork();
    if (p3 < 0) {
        perror("fork p3");
        exit(EXIT_FAILURE);
    }

    if (p3 == 0) {
        // Child process p3
        close(pipe1[0]); // Close read end of pipe1
        close(pipe1[1]); // Close write end of pipe1
        close(pipe2[1]); // Close write end of pipe2

        int num;
        while (read(pipe2[0], &num, sizeof(num)) > 0) {
            printf("Processed number: %d\n", num); // Print the processed number
        }
        close(pipe2[0]); // Close read end
        exit(EXIT_SUCCESS);
    }

    // Parent process
    close(pipe1[0]); // Close read end of pipe1
    close(pipe1[1]); // Close write end of pipe1
    close(pipe2[0]); // Close read end of pipe2
    close(pipe2[1]); // Close write end of pipe2

    // Wait for all children to finish
    wait(NULL);
    wait(NULL);
    wait(NULL);

    return 0;
}


    printf("File copied successfully from %s to %s.\n", argv[1], argv[2]);

    return 0;
}

case:2
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main() {
    int pipe1[2], pipe2[2];
    pid_t p1;

    // Create the first pipe
    if (pipe(pipe1) == -1) {
        perror("pipe1");
        exit(EXIT_FAILURE);
    }

    // Create the second pipe
    if (pipe(pipe2) == -1) {
        perror("pipe2");
        exit(EXIT_FAILURE);
    }

    // Process (p1)
    p1 = fork();
    if (p1 < 0) {
        perror("fork p1");
        exit(EXIT_FAILURE);
    }

    if (p1 == 0) {
        // Child process (p1)
        close(pipe1[0]); // Close read end of pipe1
        close(pipe2[0]); // Close read end of pipe2
        close(pipe2[1]); // Close write end of pipe2

        // Send integers 1 to 5 to pipe1
        for (int i = 1; i <= 5; i++) {
            write(pipe1[1], &i, sizeof(i)); // Write integers 1 to 5
        }
        close(pipe1[1]); // Close write end of pipe1
        exit(EXIT_SUCCESS);
    }

    // Process (p2)
    pid_t p2 = fork();
    if (p2 < 0) {
        perror("fork p2");
        exit(EXIT_FAILURE);
    }

    if (p2 == 0) {
        // Child process (p2)
        close(pipe1[1]); // Close write end of pipe1
        close(pipe2[0]); // Close read end of pipe2

        int num;
        while (read(pipe1[0], &num, sizeof(num)) > 0) {
            num *= 2; // Process the number (double it)
            write(pipe2[1], &num, sizeof(num)); // Send to process
        }
        close(pipe1[0]); // Close read end of pipe1
        close(pipe2[1]); // Close write end of pipe2
        exit(EXIT_SUCCESS);
    }

    // Parent process
    close(pipe1[0]); // Close read end of pipe1
    close(pipe1[1]); // Close write end of pipe1
    close(pipe2[1]); // Close write end of pipe2

    int processed_num;
    // Read processed numbers from pipe2
    while (read(pipe2[0], &processed_num, sizeof(processed_num)) > 0) {
        printf("Processed number: %d\n", processed_num); // Print the processed number
    }
    close(pipe2[0]); // Close read end of pipe2

    // Wait for children to finish
    wait(NULL);
    wait(NULL);

    return 0;
}

