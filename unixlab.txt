ls command 
#include <stdio.h>
#include <stdlib.h>
#include <dirent.h>  // For opendir(), readdir(), closedir()
#include <errno.h>   // For errno, perror()

int main(int argc, char *argv[]) {
    DIR *dir;                     // Pointer to the directory
    struct dirent *entry;          // Struct to hold directory entry
    char *directory;

    // If no directory is provided, use the current directory
    if (argc == 1) {
        directory = ".";
    } else if (argc == 2) {
        directory = argv[1];       // Use the directory provided as an argument
    } else {
        fprintf(stderr, "Usage: %s [directory]\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    // Open the directory
    dir = opendir(directory);
    if (dir == NULL) {
        perror("Error opening directory");
        exit(EXIT_FAILURE);
    }

    // Read and print entries from the directory
    while ((entry = readdir(dir)) != NULL) {
        printf("%s\n", entry->d_name);  // Print the name of the entry
    }

    // Close the directory
    closedir(dir);

    return 0;
}

//gcc -o my_ls my_ls.c - compile
//./my_ls -run


cat command 
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>    // For open()
#include <unistd.h>   // For read(), write(), close()

#define BUFFER_SIZE 1024

void display_file_content(const char *filename) {
    int fd;                     // File descriptor
    char buffer[BUFFER_SIZE];    // Buffer to hold file content
    ssize_t bytes_read;          // Number of bytes read

    // 1. Open the file for reading (O_RDONLY)
    fd = open(filename, O_RDONLY);
    if (fd < 0) {
        perror("Error opening file");
        exit(EXIT_FAILURE);
    }

    // 2. Read from the file and write to standard output (STDOUT_FILENO)
    while ((bytes_read = read(fd, buffer, BUFFER_SIZE)) > 0) {
        // Write the content to standard output
        if (write(STDOUT_FILENO, buffer, bytes_read) != bytes_read) {
            perror("Error writing to stdout");
            close(fd);
            exit(EXIT_FAILURE);
        }
    }

    // If read returns -1, there was an error
    if (bytes_read < 0) {
        perror("Error reading file");
        close(fd);
        exit(EXIT_FAILURE);
    }

    // 3. Close the file descriptor
    close(fd);
}

int main(int argc, char *argv[]) {
    // Check if the correct number of arguments is provided
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <filename>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    // Call the function to display the file's content
    display_file_content(argv[1]);

    return 0;
}


cp command 
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[]) {
    // Ensure two arguments are provided: source file and destination file
    if (argc != 3) {
        fprintf(stderr, "Usage: %s <sourcefile> <destinationfile>\n", argv[0]);
        exit(1);
    }

    // Open the source file for reading
    FILE *source_file = fopen(argv[1], "r");
    if (source_file == NULL) {
        perror("Error opening source file");
        exit(1);
    }

    // Open the destination file for writing (create it if it doesn't exist)
    FILE *destination_file = fopen(argv[2], "w");
    if (destination_file == NULL) {
        perror("Error opening destination file");
        fclose(source_file);  // Close the source file before exiting
        exit(1);
    }

    // Copy the contents from source file to destination file
    char ch;
    while ((ch = fgetc(source_file)) != EOF) {
        fputc(ch, destination_file);  // Write each character to the destination file
    }

    // Close both files
    fclose(source_file);
    fclose(destination_file);

    printf("File copied successfully from %s to %s.\n", argv[1], argv[2]);

    return 0;
}
